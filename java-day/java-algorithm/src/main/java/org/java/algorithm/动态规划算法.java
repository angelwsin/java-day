package org.java.algorithm;


//http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html
public class 动态规划算法 {
    
    
   /* 1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 
    2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。*/
    
    
    //贪心是每次选最大的
    //动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出
    //举例     1,3,5 硬币   凑够11元最少
    
    // d(i)  凑够i枚需要的枚数
    // i =0; d(0) = 0;
    // i =1; d(1) = 1+d(0) = 1;
    // i =2; d(2) = 1+d(2-1)= 2;
    // i =3; d(3) = 1+d(3-1)=1+d(2)=1+2 = 3;
           //d(3) = 1
    
    // d(i) = min{d(i-vj)+1}  第j个vj的面币值
    
    
    
    
    
    
    
    /*
     * 一、基本概念 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
     *  二、基本思想与策略
     * 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解， 通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
     * 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
     * 
     * 三、适用的情况 能采用动态规划求解的问题的一般要具有3个性质： (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2)
     * 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
     * （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）
     */
    
    
    
    
    

}


