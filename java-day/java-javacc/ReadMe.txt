巴科斯范式(BNF: Backus-Naur Form

PMD的核心是JavaCC解析器生成器。PMD结合运用JavaCC和EBNF（扩展巴科斯-诺尔范式，Extended Backus-Naur Formal）语法，再加上JJTree，把Java源代码解析成抽象语法树（AST，Abstract Syntax Tree）

BNF的元符号 

::=    表示“被定义为 ” 
|      表示“或者” 
< >    尖括号用于括起类别名字 尖括号( < > )内包含的为必选项
BNF规则是一个推导规则的几何，写为：
<symbol> ::= __expression__
其中右面是若干个"|"分割的表达式（｜是提供选择，indicating a choice），出现在左边的<symbol>是非终结符，从未出现在左边的是终结符。

说明： 
1、 每个规则中只包含一个::=符号，它将规则分为左右两部分。左边表示一个非终结符号（代表某个语法成分，通常对应有确定含义），
也就是说它可以被"::="右边的部分所替换。非终结符号必须用"<"和">"括起来表示它是一个非终结符号。右边是由非终结符或 “|”与终结符组成的一个符号串，或由“｜”隔开的几个这样的符号串。这里终结符指程序设计语言字符集的基本字符。 
2、 由一串非终结符和以其字面意义出现在规则中终结符所组成。竖线"|"可以用在两个符号(包括终结符和非终结符)中间，表示使用"|"左边或右边的符号均可。 
3、 "::="被定义的非终结符可以出现在"::="右边的中，表示递归定义。
    例：用BNF定义一个文法 
     S∷=AbS′|bS′|cS′ 
     S′∷=aS′|ε 
     A∷=Bc|a 
    B∷=Sb|b



扩展符号的BNF范式
[…] 可选项
{…} 大括号( { } )内包含的为可重复0至无数次的项
重复项(可重复0或多次)
(…) 组合项  多个做一个整体
:n:n 后缀表示范围,如：:1:8，表示“用1到8个字符命名”
“双引号内的字符表示这些字符本身，要表示双引号要用如下形式：” ” ”

 ABNF是在BNF基础上扩展的增强型巴克斯范式，主要用于描述文本编码，平衡了压缩性和简单性，具有合理的表达能力，大多数Internet应用层标准都可用ABNF来描述



EBNF 排除了 BNF 的一些缺陷:

BNF 为自身使用了符号 (<, >, |, ::=)。当它们出现在要定义的语言中的时候，BNF 不能不加以修改或解释的使用。
BNF-语法在一行中只表示一个规则。
EBNF 解决了这些问题:

终结符被严格的包围在引号 ("..." 或 '...') 中。给非终结符的尖括号 ("<...>")可以省略。
通常使用终止字符分号结束一个规则。
进一步还提供了定义重复次数，排除法选择(比如除了引号的所有字符)和注释等的增强机制。

不管所有这些增强，EBNF 在能定义的语言的意义上不比 BNF 更强大。在原理上用 EBNF 定义的任何文法都可以用 BNF 表达。但是经常导致可观的更多规则的表示


巴科斯范式的内容
在双引号中的字("word")代表着这些字符本身。而double_quote用来代表双引号。
在双引号外的字（有可能有下划线）代表着语法部分。
尖括号( < > )内包含的为必选项。
方括号( [ ] )内包含的为可选项。
大括号( { } )内包含的为可重复0至无数次的项。
竖线( | )表示在其左右两边任选一项，相当于"OR"的意思。
::= 是“被定义为”的意思。


 
巴科斯范式示例
这是用BNF来定义的Java语言中的For语句的实例：
FOR_STATEMENT ::=
"for" "(" ( (variable_declaration ";") |
( expression ";" ) | ";" )
[ expression ] ";"
[ expression ]
")" statement


lex和yacc
JavaCC(Java Compiler Compiler)是一个用JAVA开发的最受欢迎的语法分析生成器。这个分析生成器工具可以读取上下文无关且有着特殊意义的语法并把它转换成可以识别且匹配该语法的JAVA程序。
JavaCC可以在Java虚拟机(JVM) V1.2或更高的版本上使用，它是100%的纯Java代码，
可以在多种平台上运行，与Sun当时推出Java的口号"Write Once Run Anywhere"相一致。JavaCC还提供JJTree工具来帮助我们建立语法树，JJDoc工具为我们的源文件生成BNF范式(巴科斯-诺尔范式)文档(Html)。

抽象语法树（AST）
http://blog.csdn.net/zhouhuozhi/article/details/4250258




JJTree
和YACC等一样，JavaCC不直接支持分析树或抽象语法树（AST）的生成，如果要完成这些功能，用户需要自己编写相应的代码。幸运的是，JavaCC有一个扩充支持分析树或抽象语法树的生成，这就是JJTree。

实际上，JJTree可以看成是JavaCC的预处理程序。它的输入文件的后缀是jjt。经它处理之后的jj文件就包含了生成分析树的能力。
JJTree采用压栈出栈的方法生成分析树。当它碰到一个非终结符要展开时，它会做一个标记，然后开始分析展开后的各个非终结符（此时，分析子树作为节点压入栈中）
，之后从栈中弹出合适个数的节点（分析子树），并以被展开的非终结符生成一个新节点，以这个新节点为根节点，以刚弹出的节点为子节点生成新的分析子树（分析树）。